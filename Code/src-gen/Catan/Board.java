// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------
package Catan;

import java.util.*;

public class Board {
	private final List<Tile> tiles = new ArrayList<>();
	private final List<Node> nodes = new ArrayList<>();
	private final List<Road> roads = new ArrayList<>();

	public List<Tile> getTiles() { return List.copyOf(tiles); }
	public List<Node> getNodes() { return List.copyOf(nodes); }
	public List<Road> getRoads() { return List.copyOf(roads); }

	public Node getNode(int nodeId) { return nodes.get(nodeId); }

	public void setupDefaultMap() {
		tiles.clear();
		nodes.clear();
		roads.clear();

		for (int id = 0; id < BoardTopology.NODE_COUNT; id++) nodes.add(new Node(id));
		BoardTopology.rebuildNeighborsFromEdges();

		// Tiles
		tiles.add(new Tile(0,  ResourceType.LUMBER, 10));
		tiles.add(new Tile(1,  ResourceType.GRAIN, 11));
		tiles.add(new Tile(2,  ResourceType.BRICK, 8));
		tiles.add(new Tile(3,  ResourceType.ORE,   3));
		tiles.add(new Tile(4,  ResourceType.WOOL, 11));
		tiles.add(new Tile(5,  ResourceType.WOOL,  5));
		tiles.add(new Tile(6,  ResourceType.WOOL, 12));
		tiles.add(new Tile(7,  ResourceType.GRAIN,  3));
		tiles.add(new Tile(8,  ResourceType.ORE,    6));
		tiles.add(new Tile(9,  ResourceType.LUMBER, 4));
		tiles.add(new Tile(10, ResourceType.ORE,    6));
		tiles.add(new Tile(11, ResourceType.GRAIN,  9));
		tiles.add(new Tile(12, ResourceType.LUMBER, 5));
		tiles.add(new Tile(13, ResourceType.BRICK,  9));
		tiles.add(new Tile(14, ResourceType.BRICK,  8));
		tiles.add(new Tile(15, ResourceType.GRAIN,  4));
		tiles.add(new Tile(16, ResourceType.DESERT, 0));
		tiles.add(new Tile(17, ResourceType.LUMBER, 2));
		tiles.add(new Tile(18, ResourceType.WOOL,  10));
	}

	public void produceResources(int roll) {
		if (roll == 7) return;

		for (Tile t : tiles) {
			if (!t.producesOn(roll)) continue;

			System.out.println("PRODUCE: tile " + t.getTileId() + " " + t.getResourceType()
					+ " token=" + t.getNumberToken()
					+ " nodes=" + Arrays.toString(BoardTopology.tileNodes[t.getTileId()]));

			for (int nodeId : BoardTopology.tileNodes[t.getTileId()]) {
				Node n = nodes.get(nodeId);
				if (!n.isOccupied()) continue;

				Building b = n.getOccupant();
				int amount = (b instanceof City) ? 2 : 1;
				b.getOwner().addResources(t.getResourceType(), amount);
				System.out.println("  -> P" + b.getOwner().getId() + " gets " + amount + " " + t.getResourceType());
			}
		}
	}

	// ---------------- Roads ----------------

	public boolean canPlaceRoad(Player p, Node a, Node b) {
		if (p == null || a == null || b == null) return false;
		if (a.getNodeId() == b.getNodeId()) return false;
		if (!BoardTopology.nodeNeighbors.get(a.getNodeId()).contains(b.getNodeId())) return false;

		// already occupied edge?
		for (Road r : roads) {
			int ra = r.getA().getNodeId(), rb = r.getB().getNodeId();
			if ((ra == a.getNodeId() && rb == b.getNodeId()) || (ra == b.getNodeId() && rb == a.getNodeId())) return false;
		}

		// If player has no roads yet, allow anywhere (matches your current behavior)
		if (countPlayerRoads(p) == 0) return true;

		// Must connect to own road or own building
		if (hasPlayersRoadTouching(p, a) || hasPlayersRoadTouching(p, b)) return true;
		return nodeHasPlayersBuilding(p, a) || nodeHasPlayersBuilding(p, b);
	}

	public boolean placeRoad(Player p, Node a, Node b) {
		if (!canPlaceRoad(p, a, b)) return false;
		roads.add(new Road(p, a, b));
		return true;
	}

	private int countPlayerRoads(Player p) {
		int c = 0;
		for (Road r : roads) if (r.getOwner().getId() == p.getId()) c++;
		return c;
	}

	private boolean hasPlayersRoadTouching(Player p, Node n) {
		for (Road r : roads) {
			if (r.getOwner().getId() != p.getId()) continue;
			if (r.connects(n)) return true;
		}
		return false;
	}

	// ---------------- Settlements / Cities ----------------

	public boolean canPlaceSettlementInitial(Player p, Node at) {
		return canPlaceSettlementHere(p, at, true);
	}

	public boolean placeSettlementInitial(Player p, Node at) {
		if (!canPlaceSettlementInitial(p, at)) return false;
		Settlement s = new Settlement(p, at);
		at.place(s);
		p.addVictoryPoints(s.victoryPoints());
		return true;
	}

	public boolean canPlaceSettlement(Player p, Node at) {
		return canPlaceSettlementHere(p, at, false);
	}

	private boolean canPlaceSettlementHere(Player p, Node at, boolean ignoreRoadRequirement) {
		if (p == null || at == null) return false;
		if (at.isOccupied()) return false;

		// distance rule: no adjacent occupied nodes
		for (int nb : BoardTopology.nodeNeighbors.get(at.getNodeId())) {
			if (nodes.get(nb).isOccupied()) return false;
		}

		if (ignoreRoadRequirement) return true;

		// If player has no roads yet, allow (keeps your current permissive behavior)
		if (countPlayerRoads(p) == 0) return true;

		// Otherwise must connect to own road
		return hasPlayersRoadTouching(p, at);
	}

	public boolean placeSettlement(Player p, Node at) {
		if (!canPlaceSettlement(p, at)) return false;
		Settlement s = new Settlement(p, at);
		at.place(s);
		p.addVictoryPoints(s.victoryPoints());
		return true;
	}

	public boolean canUpgradeToCity(Player p, Node at) {
		if (p == null || at == null) return false;
		if (!nodeHasPlayersBuilding(p, at)) return false;

		Building b = at.getOccupant();
		return (b instanceof Settlement);
	}

	public boolean upgradeToCity(Player p, Node at) {
		if (!canUpgradeToCity(p, at)) return false;

		at.clear();
		City c = new City(p, at);
		at.place(c);

		p.addVictoryPoints(c.victoryPoints());
		return true;
	}

	private boolean nodeHasPlayersBuilding(Player p, Node n) {
		return n.isOccupied() && n.getOccupant().getOwner().getId() == p.getId();
	}

}
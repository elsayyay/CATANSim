// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package Catan;

import java.util.*;

public class Player {
    private final int id;
    private int victoryPoints = 0;
    private final List<ResourceCard> hand = new ArrayList<>();
    private final Random rng = new Random();

    public Player(int id) {
        this.id = id;
    }

    public int getId() { return id; }
    public int getVictoryPoints() { return victoryPoints; }
    public int handSize() { return hand.size(); }

    void addVictoryPoints(int points) {
        victoryPoints += points;
    }

    public void addResources(ResourceType type, int count) {
        if (count < 0) throw new IllegalArgumentException("count must be >= 0");
        if (type == ResourceType.DESERT) return;
        for (int i = 0; i < count; i++) hand.add(new ResourceCard(type));
    }

    public boolean hasResources(Cost cost) {
        EnumMap<ResourceType, Integer> c = countHand();
        return c.getOrDefault(ResourceType.BRICK, 0)  >= cost.brick
                && c.getOrDefault(ResourceType.LUMBER, 0) >= cost.lumber
                && c.getOrDefault(ResourceType.WOOL, 0)   >= cost.wool
                && c.getOrDefault(ResourceType.GRAIN, 0)  >= cost.grain
                && c.getOrDefault(ResourceType.ORE, 0)    >= cost.ore;
    }

    public void pay(Cost cost) {
        if (!hasResources(cost)) throw new IllegalStateException("Not enough resources.");
        removeFromHand(ResourceType.BRICK, cost.brick);
        removeFromHand(ResourceType.LUMBER, cost.lumber);
        removeFromHand(ResourceType.WOOL, cost.wool);
        removeFromHand(ResourceType.GRAIN, cost.grain);
        removeFromHand(ResourceType.ORE, cost.ore);
    }

    public String takeTurn(Game game) {
        Board board = game.getBoard();

        String action = tryBuildOnce(board);
        return action;
    }

    private String tryBuildOnce(Board board) {
        String action;

        if (hasResources(Cost.settlement()) && !(action = buildSettlement(board)).startsWith("PASS")) {
            return action;
        }
        if (hasResources(Cost.road())       && !(action = buildRoad(board)).startsWith("PASS")){
            return action;
        }
        if (hasResources(Cost.city()) && !(action = buildCity(board)).startsWith("PASS")){
            return action;
        }
        return pass();
    }

    private String buildSettlement(Board board) {
        List<Node> spots = new ArrayList<>();
        for (Node n : board.getNodes()) {
            if (board.canPlaceSettlement(this, n)){
                spots.add(n);
            }
        }
        if (spots.isEmpty()) {
            return pass();
        }

        Node at = spots.get(rng.nextInt(spots.size()));
        pay(Cost.settlement());
        return board.placeSettlement(this, at)
                ? "BUILD SETTLEMENT at node " + at.getNodeId()
                : pass();
    }

    private String buildCity(Board board) {
        List<Node> spots = new ArrayList<>();
        for (Node n : board.getNodes()) {
            if (board.canUpgradeToCity(this, n)) {
                spots.add(n);
            }
        }
        if (spots.isEmpty()) {
            return pass();
        }

        Node at = spots.get(rng.nextInt(spots.size()));
        pay(Cost.city());
        return board.upgradeToCity(this, at)
                ? "BUILD CITY at node " + at.getNodeId()
                : pass();
    }

    private String buildRoad(Board board) {
        List<int[]> edges = new ArrayList<>();

        for (Node a : board.getNodes()) {
            int aId = a.getNodeId();
            for (int bId : BoardTopology.nodeNeighbors.get(aId)) {
                if (aId >= bId){
                    continue; // avoid duplicates
                }
                Node b = board.getNode(bId);
                if (board.canPlaceRoad(this, a, b)){
                    edges.add(new int[]{aId, bId});
                }
            }
        }
        if (edges.isEmpty()){
            return pass();
        }

        int[] e = edges.get(rng.nextInt(edges.size()));
        Node a = board.getNode(e[0]);
        Node b = board.getNode(e[1]);

        pay(Cost.road());
        return board.placeRoad(this, a, b)
                ? "BUILD ROAD " + a.getNodeId() + "-" + b.getNodeId()
                : pass();
    }

    private String pass() {
        return "PASS";
    }

    private EnumMap<ResourceType, Integer> countHand() {
        EnumMap<ResourceType, Integer> counts = new EnumMap<>(ResourceType.class);
        for (ResourceCard card : hand) counts.merge(card.type(), 1, Integer::sum);
        return counts;
    }

    private void removeFromHand(ResourceType type, int count) {
        for (int i = 0; i < count; i++) {
            for (int j = 0; j < hand.size(); j++) {
                if (hand.get(j).type() == type) { hand.remove(j); break; }
            }
        }
    }

    

}
